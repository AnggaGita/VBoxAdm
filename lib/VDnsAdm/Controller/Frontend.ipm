package VDnsAdm::Controller::Frontend;

use base 'CGI::Application';

use strict;
use warnings;

use CGI::Carp qw(fatalsToBrowser);

use Encode;

# TODO add punnycode translator

# Needed for database connection
use CGI::Application::Plugin::DBH (qw/dbh_config dbh/);

use CGI::Application::Plugin::Redirect;

# http://search.cpan.org/~ceeshek/CGI-Application-Plugin-Session-1.03/lib/CGI/Application/Plugin/Session.pm
use CGI::Application::Plugin::Session;

# http://search.cpan.org/~ceeshek/CGI-Application-Plugin-TT-1.05/lib/CGI/Application/Plugin/TT.pm
use CGI::Application::Plugin::TT;

# http://search.cpan.org/~dhorne/CGI-Application-Plugin-RequireSSL-0.04/lib/CGI/Application/Plugin/RequireSSL.pm
use CGI::Application::Plugin::RequireSSL;

# http://search.cpan.org/~silasmonk/CGI-Application-Plugin-Authentication-0.18/lib/CGI/Application/Plugin/Authentication.pm
use CGI::Application::Plugin::Authentication;

use Config::Std;
use DBI;
use Readonly;
use Try::Tiny;

use VWebAdm::Utils '@VERSION@';
use VDnsAdm::L10N '@VERSION@';
use VWebAdm::SaltedHash '@VERSION@';
use VWebAdm::Logger '@VERSION@';

use VWebAdm::Model::MessageQueue '@VERSION@';
use VWebAdm::Model::User '@VERSION@';

use VDnsAdm::Model::Domain '@VERSION@';
use VDnsAdm::Model::Record '@VERSION@';
use VDnsAdm::Model::Supermaster '@VERSION@';

our $VERSION = '@VERSION@';

Readonly my $ENTRIES_PER_PAGE => 20;

############################################
# Usage      : Invoked by CGIApp
# Purpose    : Setup the Application
# Returns    : Nothing
# Parameters : None
# Throws     : no exceptions
# Comments   : none
# See Also   : n/a
# setup is run right after cgiapp_init
sub setup {
    my $self = shift;

    my $Logger = VWebAdm::Logger::->new( { 'facility' => 'VDnsAdm/Frontend', } );
    $self->{'logger'} = $Logger;

    # define the default run mode
    $self->start_mode('public_login');

    # define the mappings between the rm parameter and the actual sub
    $self->run_modes(

        #
        # Public
        #
        'public_login' => 'show_login',

        #
        # Private
        #

        # General
        'welcome' => 'show_welcome',

        # Domains
        'domains'       => 'show_domains',
        'domain'        => 'show_domain',
        'create_domain' => 'show_create_domain',
        'add_domain'    => 'show_add_domain',
        'remove_domain' => 'show_remove_domain',
        'edit_domain'   => 'show_edit_domain',
        'update_domain' => 'show_update_domain',

        # Mailboxes
        'mailboxes'      => 'show_mailboxes',
        'create_mailbox' => 'show_create_mailbox',
        'add_mailbox'    => 'show_add_mailbox',
        'remove_mailbox' => 'show_remove_mailbox',
        'edit_mailbox'   => 'show_edit_mailbox',
        'update_mailbox' => 'show_update_mailbox',

        # Log
        'log' => 'show_log',

        # Admins
        'admins' => 'show_admins',
    );

    # Authentication
    # Setup authentication using CGI::Application::Plugin::Authentication
    # Since we want to be able to support salted passwords, this is a bit messy.
    #
    # Contraints:
    # Only users who are either siteadmin or domainadmin should be able to login
    # and their account (= mailbox) must be active. Furthermore the username is
    # local_part@domain but those are stored in two different tables. So
    # we need to join those tables by specifying two tables and CONCAT the
    # fields together.
    #
    # Since the plugin does not support OR contraints we have to work around that issue.
    # In doubt I suggest to have a look the source code of the plugin.
    #
    # Filters:
    # The filter receives the user supplied password and the content of the column it is
    # applied to, extracts the pwscheme and salt, hashes the user supplied pass and returns
    # the password hash computed with the old salt and pwscheme. The plugin compares
    # the result with the unmodified column entry.
    $self->authen->config(
        DRIVER => [
            'DBI',
            TABLES      => [ 'mailboxes', 'domains' ],
            CONSTRAINTS => {
                "CONCAT(mailboxes.local_part,'\@',domains.name)" => '__CREDENTIAL_1__',
                'mailboxes.is_active'                            => '1',
                'domains.is_active'                              => '1',

                # WARNING: This contraint relies on an implementation detail of Plugin::Authentication!
                # This is bad style, but there is no other way right now.
                # The correct way would probably to create a custom Authen plugin.
                '(mailboxes.is_siteadmin OR mailboxes.is_domainadmin) AND 1' => '1',
            },
            COLUMNS => { 'dovecotpw:mailboxes.password' => '__CREDENTIAL_2__', },
            FILTERS => {
                'dovecotpw' => sub {

                    # since we may use salted passwords, we have to do our own
                    # password verification. a simple string eq would not do.
                    my $param   = shift;    # unused, always empty
                    my $plain   = shift;    # password from user
                    my $pwentry = shift;    # password hash from db
                    my ( $pwscheme, undef, $salt ) = &VBoxAdm::SaltedHash::split_pass($pwentry);
                    my $passh = &VBoxAdm::SaltedHash::make_pass( $plain, $pwscheme, $salt );
                    return $passh;
                },
            }
        ],
        LOGOUT_RUNMODE      => 'public_login',
        LOGIN_RUNMODE       => 'public_login',
        POST_LOGIN_CALLBACK => \&post_login_callback,
    );

    # only enable authen if called as CGI, this helps with testing and debugging from the commandline
    if ( !$self->is_shell() ) {

        # TODO DEVEL # $self->authen->protected_runmodes(qr/^(?!public_|api)/);
        $self->authen->protected_runmodes(qr/WHATEVER/);
    }

    #
    # Configuration
    #
    # Valid config file locations to try
    my @conffile_locations = qw(
      vdnsadm.conf
      conf/vdnsadm.conf
      /etc/vdnsadm/vdnsadm.conf
      @CFGDIR@/vdnsadm/vdnsadm.conf
    );

    # if the application if run as a FastCGI app, the server might
    # provide an additional configuration location. if the points to file
    # add it to the list of possible locations
    if ( $ENV{CGIAPP_CONFIG_FILE} && -f $ENV{CGIAPP_CONFIG_FILE} ) {
        unshift( @conffile_locations, $ENV{CGIAPP_CONFIG_FILE} );
    }

    my ( %config, $conffile_used );

    # Try all config file locations
    foreach my $loc (@conffile_locations) {
        if ( -r $loc ) {
            $conffile_used = $loc;
            read_config $loc => %config;
            last;
        }
    }
    if ( !$conffile_used ) {
        $self->{'logger'}
          ->log( message => "setup - Warning: No readable config file found in search path! (" . join( ':', @conffile_locations ) . ")", level => 'warning', );
    }
    $self->{config} = \%config;

    #
    # Database
    #
    my $user = $config{'default'}{'dbuser'} || 'root';
    my $pass = $config{'default'}{'dbpass'} || 'root';
    my $db   = $config{'default'}{'dbdb'}   || 'vdnsadm';
    my $port = $config{'default'}{'dbport'} || 3306;
    my $host = $config{'default'}{'dbhost'} || 'localhost';
    my $dsn  = "DBI:mysql:database=$db;user=$user;password=$pass;host=$host;port=$port";
    $self->{base_url}     = $config{'cgi'}{'base_url'}     || '/cgi-bin/vdnsadm.pl';
    $self->{media_prefix} = $config{'cgi'}{'media_prefix'} || '';

    # Connect to DBI database, same args as DBI->connect();
    # uses connect_cached for persistent connections
    # this should have no effect for CGI and speed up FastCGI
    # http://www.cosmocode.de/en/blog/gohr/2009-12/10-surviving-the-perl-utf-8-madness
    # http://www.gyford.com/phil/writing/2008/04/25/utf8_mysql_perl.php
    # http://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default
    # mysql_enable_utf8 should prepare the connection for UTF-8. It will also SET NAMES utf8.
    # Scripts, Database, Sourcecode, Userdata ... everything should be in UTF-8
    # the only point were we could deal with non-UTF-8 is when we output data to
    # non-utf-8 capable browsers (are there any?)
    $self->dbh_config(
        sub {
            DBI->connect_cached(
                $dsn, undef, undef,
                {
                    PrintError        => 0,
                    RaiseError        => 0,
                    mysql_enable_utf8 => 1,
                }
            );
        }
    );
    if ( !$self->dbh ) {
        $self->{'logger'}->log( message => "setup - Failed to establish DB connection with DSN $dsn and error message: " . DBI->errstr, level => 'error', );
        die("Could not connect to DB.");
    }

    #
    # L10N
    #
    # the user handle, will try to determine the appropriate language ... look at the docs of Locale::Maketext
    $self->{lh} = VDnsAdm::L10N->get_handle();

    # this handle is used for logging. logged messages should always be in english
    $self->{lh_en} = VDnsAdm::L10N->get_handle('en');

    #
    # Templating unsing the Template Toolkit
    #
    # Filters:
    # Have a look at the docs of the tt for info on dynamic filters.
    # Short version: they allow filters with more than one argument.
    # highlight provides syntax highlightning for the search
    # l10n provides localization via Locale::Maketext
    my @include_path = qw(tpl/ ../tpl/ /usr/lib/vwebadm/tpl);
    if ( $config{'cgi'}{'template_path'} && -d $config{'cgi'}{'template_path'} ) {
        unshift( @include_path, $config{'cgi'}{'template_path'} );
    }
    $self->tt_config(
        TEMPLATE_OPTIONS => {
            ENCODING     => 'utf8',
            INCLUDE_PATH => \@include_path,
            POST_CHOMP   => 1,
            FILTERS      => {
                'currency' => sub { sprintf( '%0.2f', @_ ) },

                # dynamic filter factory, see TT manpage
                'highlight' => [
                    sub {
                        my ( $context, $search ) = @_;

                        return sub {
                            my $str = shift;
                            if ($search) {
                                $str =~ s/($search)/<span class='hilighton'>$1<\/span>/g;
                            }
                            return $str;
                          }
                    },
                    1
                ],

                # A localization filter. Turn the english text into the localized counterpart using Locale::Maketext
                'l10n' => [
                    sub {
                        my ( $context, @args ) = @_;

                        return sub {
                            my $str = shift;
                            return $self->{lh}->maketext( $str, @args );
                          }
                    },
                    1,
                ],
            }
        }
    );
    $self->tt_params( base_url     => $self->{base_url} );
    $self->tt_params( media_prefix => $self->{media_prefix} );

    # setup classes if the user is logged in
    if ( $self->authen->is_authenticated && $self->authen->username ) {
        my $Messages = VWebAdm::Model::MessageQueue::->new(
            {
                'lh'      => $self->{'lh'},
                'lh_en'   => $self->{'lh_en'},
                'session' => $self->session,
            }
        );

        # if we can not create a new user object we MUST NOT die but redirect to login page instead
        my $User;
        eval {
            $User = VWebAdm::Model::User::->new(
                {
                    'dbh' => $self->dbh,

                    # TODO DEVEL 'username' => $self->authen->username,
                    'username' => 'admin',
                    'force'    => 1,
                    'msgq'     => $Messages,
                    'logger'   => $Logger,
                    'config'   => $self->{'config'},
                }
            );
            $User->login('forced-login');
        };
        if ( $@ || !$User ) {
            $self->log("Could not create User Object: $@");
        }
        else {
            $self->{'Messages'} = $Messages;
            $self->{'User'}     = $User;
            my $arg_ref = {
                'dbh'    => $self->dbh,
                'user'   => $User,
                'msgq'   => $Messages,
                'logger' => $Logger,
                'config' => $self->{'config'},
            };
            $self->{'Domain'}      = VDnsAdm::Model::Domain::->new($arg_ref);
            $self->{'Record'}      = VDnsAdm::Model::Record::->new($arg_ref);
            $self->{'Supermaster'} = VDnsAdm::Model::Supermaster::->new($arg_ref);
        }
    }

    # to make perlcritic happy
    return 1;
}

sub teardown {
    my $self = shift;

    # Disconnect when done
    $self->dbh->disconnect();

    # to make perlcritic happy
    return 1;
}

#
# CGI::Application Hooks
#
# cgiapp_init is run right before setup
sub cgiapp_init {
    my $self = shift;

    # Everything should be in UTF-8!
    $self->query->charset('UTF-8');

    # Configure RequireSSL
    my $ignore_ssl_check = 0;
    if ( $self->is_shell() || $self->is_localnet() || $self->{config}{'cgi'}{'no_ssl'} ) {
        $ignore_ssl_check = 1;
    }

    $self->config_requiressl(
        'keep_in_ssl'  => 1,
        'ignore_check' => $ignore_ssl_check,
    );

    # to make perlcritic happy
    return 1;
}

#
# Template::Toolkit Hooks
#

# post processing hooks
sub tt_post_process {
    my $self    = shift;
    my $htmlref = shift;

    # nop
    return;
}

# pre processing set commonly used variables for the templates
sub tt_pre_process {
    my ( $self, $file, $vars ) = @_;

    $vars->{username}       = $self->authen->username;
    $vars->{system_domain}  = $self->{config}{'default'}{'domain'} || 'localhost';
    $vars->{long_forms}     = $self->{config}{'cgi'}{'long_forms'} || 0;
    $vars->{version}        = $VERSION;
    $vars->{messages}       = $self->get_messages();
    $vars->{is_siteadmin}   = $self->user->is_siteadmin() if $self->user();
    $vars->{is_domainadmin} = $self->user->is_domainadmin() if $self->user();

    return;
}

#
# Misc. private Subs
#

############################################
# Usage      : $self->log('message');
# Purpose    : Log a message to the log table and syslog
# Returns    : true on success
# Parameters : a string
# Throws     : no exceptions
# Comments   : none
# See Also   : n/a
sub log {
    my $self = shift;
    my $msg  = shift;

    # Get our database connection
    my $dbh = $self->dbh();

    if ($msg) {
        $self->{'logger'}->log( message => $msg, level => 'debug', );
        my $query = "INSERT INTO log (ts,msg) VALUES(NOW(),?)";
        my $sth   = $dbh->prepare($query)
          or $self->{'logger'}->log( message => 'Could not prepare Query: ' . $query . ', Error: ' . DBI->errstr );
        if ( $sth->execute($msg) ) {
            $sth->finish();
            return 1;
        }
        else {
            $self->{'logger'}->log( message => 'Could not execute Query: ' . $query . ', Args: ' . $msg . ', Error: ' . $sth->errstr );
            $sth->finish();
            return;
        }
    }
    else {
        return;
    }
}

############################################
# Usage      : called by Authentication plugin after successfull login
# Purpose    : log login and setup user env.
# Returns    : always true
# Parameters : none
# Throws     : no exceptions
# Comments   : none
# See Also   : n/a
sub post_login_callback {
    my $self = shift;

    $self->log_login();

    return 1;
}

############################################
# Usage      : $self->log_login();
# Purpose    : convenience method for logging a user login event
# Returns    : always true
# Parameters : none
# Throws     : no exceptions
# Comments   : none
# See Also   : n/a
sub log_login {
    my $self = shift;
    return unless ( $self->authen->is_authenticated );
    $self->log( "User " . $self->authen->username . " logged in.", );
    return 1;
}

############################################
# Usage      : $self->add_message('warning','message');
# Purpose    : Add a message to the notification message stack
# Returns    : always true
# Parameters : the type and the message
# Throws     : no exceptions
# Comments   : none
# See Also   : n/a
# add entry to notify
sub add_message {
    my $self = shift;
    my $type = shift;
    my $msg  = shift;
    return if !$self->{'Messages'};
    $self->{'Messages'}->push( $type, $msg );
    return 1;
}

############################################
# Usage      : $self->get_messages();
# Purpose    : Return all messages from the message stack and remove them
# Returns    : a hashref w/ the messages by priority
# Parameters : none
# Throws     : no exceptions
# Comments   : none
# See Also   : n/a
# get and reset notify
sub get_messages {
    my $self = shift;
    return if !$self->{'Messages'};
    my @msgs = $self->{'Messages'}->pop();
    return \@msgs;
}

############################################
# Usage      : $self->peek_message();
# Purpose    : Return the message stack w/o removing the messages
# Returns    : a hashref w/ the message by priority
# Parameters : none
# Throws     : no exceptions
# Comments   : none
# See Also   : n/a
# get notify (no reset)
sub peek_message {
    my $self = shift;
    return if !$self->{'Messages'};
    my @msgs = $self->{'Messages'}->peek();
    return \@msgs;
}

############################################
# Usage      : $self->is_shell()
# Purpose    : is the script run from a shell?
# Returns    : true if no CGI
# Parameters : none
# Throws     : no exceptions
# Comments   : none
# See Also   : n/a
sub is_shell {
    my $self = shift;
    if ( $ENV{'DISPLAY'} && $ENV{'PS1'} && $ENV{'SHELL'} && $ENV{'USER'} ) {
        if (   $ENV{'DOCUMENT_ROOT'}
            || $ENV{'GATEWAY_INTERFACE'}
            || $ENV{'HTTP_HOST'}
            || $ENV{'REMOTE_ADDR'}
            || $ENV{'REQUEST_METHOD'}
            || $ENV{'SERVER_SOFTWARE'} )
        {
            return;
        }
        else {
            return 1;
        }
    }
    else {
        return;
    }
}

sub user {
    my $self = shift;
    return $self->{'User'};
}

############################################
# Usage      : $self->is_localnet()
# Purpose    : tell if the user is on a local, i.e. somewhat trusted, network
# Returns    : true if localnet or shell
# Parameters : none
# Throws     : no exceptions
# Comments   : none
# See Also   : n/a
sub is_localnet {
    if ( !$ENV{'REMOTE_ADDR'} ) {
        return 1;    # shell, coz' local
    }
    else {
        if ( $ENV{'REMOTE_ADDR'} =~ m/^(192\.168|172\.(1[6-9]|2\d|3[0-1])|10)\./ ) {
            return 1;
        }
        else {
            return;
        }
    }
}

############################################
# Usage      :
# Purpose    : Return the domain name to a given domain id.
# Returns    :
# Parameters :
# Throws     : no exceptions
# Comments   : none
# See Also   : n/a
sub get_domain_byid {
    my $self      = shift;
    my $domain_id = shift;

    return $self->{'Domain'}->get_name($domain_id);
}

#
# Public
#

sub show_login {
    my $self = shift;

    $self->session_delete();

    my %params = (
        title        => $self->{lh}->maketext('VDnsAdm Login'),
        nonavigation => 1,
    );

    return $self->tt_process( 'vwebadm/login.tpl', \%params );
}

#
# Private
#

#
# General / Misc.
#
sub show_welcome {
    my $self = shift;

    my %params = (
        'title'   => $self->{lh}->maketext('VDnsAdm Overview'),
        'current' => 'welcome',
    );

    return $self->tt_process( 'vdnsadm/welcome.tpl', \%params );
}

#
# Domains
#

sub show_domains {
    my $self = shift;

    # Get our database connection
    my $dbh = $self->dbh();

    # Get CGI Query object
    my $q = $self->query();

    my $page   = $q->param('page') || 1;
    my $search = $q->param('search');
    my %params = ( 'Search' => $search, );

    my $sql_records = "SELECT COUNT(*) FROM records WHERE domain_id = ?";
    my $sth_records = $dbh->prepare($sql_records);

    my @domains = $self->{'Domain'}->list( \%params );

    foreach my $domain (@domains) {
        if ( $sth_records->execute( $domain->{'id'} ) ) {
            $domain->{'num_records'} = $sth_records->fetchrow_array();
        }
    }

    $sth_records->finish();

    %params = (
        'title'   => $self->{lh}->maketext('VDnsAdm Domains'),
        'current' => 'domains',
        'domains' => \@domains,
        'search'  => $search,
    );

    return $self->tt_process( 'vdnsadm/domain/list.tpl', \%params );
}

sub show_domain {
    my $self = shift;

    if ( !$self->user->is_siteadmin() ) {
        my $msg = "You are not authorized to access this page.";
        $self->log( $msg . ". User: " . $self->authen->username );
        $self->add_message( 'error', $self->{lh}->maketext($msg) );
        $self->redirect( $self->{base_url} . '?rm=welcome' );
        return;
    }

    # Get our database connection
    my $dbh = $self->dbh();

    # Get CGI Query object
    my $q = $self->query();

    my $domain_id = $q->param('domain_id') || undef;

    if ( !$domain_id || $domain_id !~ m/^\d+$/ ) {
        my $msg = "Invalid Domain-ID.";
        $self->log( $msg . ". User: " . $self->authen->username );
        $self->add_message( 'error', $msg );
        $self->redirect( $self->{base_url} . '?rm=welcome' );
        return;
    }

    my $sql = undef;
    my $sth = undef;

    # Get Domain name
    # TODO use Domain model
    $sql = "SELECT name FROM domains WHERE id = ?";
    $sth = $dbh->prepare($sql);
    $sth->execute($domain_id);
    my $domain_name = $sth->fetchrow_array();
    $sth->finish();

    # Get Records
    # TODO use record model
    $sql = "SELECT id,local_part,name,is_active FROM mailboxes WHERE domain_id = ? ORDER BY local_part";
    $sth = $dbh->prepare($sql);
    $sth->execute($domain_id);
    my @mailboxes = ();
    while ( my ( $id, $local_part, $name, $is_active ) = $sth->fetchrow_array() ) {
        push( @mailboxes, { id => $id, local_part => $local_part, name => $name, is_active => $is_active, } );
    }
    $sth->finish();

    my @bc = ();
    push( @bc, { 'rm' => 'welcome',                        caption => 'Overview', } );
    push( @bc, { 'rm' => 'domains',                        caption => 'Domains', } );
    push( @bc, { 'rm' => 'domain&domain_id=' . $domain_id, caption => 'View Domain ' . $domain_name, } );

    my %params = (
        'title'      => $self->{lh}->maketext( 'VBoxAdm Domain: [_1]', $domain_name ),
        'current'    => 'domains',
        'domain'     => $domain_name,
        'mailboxes'  => \@mailboxes,
        'breadcrumb' => \@bc,
    );

    return $self->tt_process( 'vdnsadm/domain/show.tpl', \%params );
}

sub show_create_domain {
    my $self = shift;

    if ( !$self->user->is_siteadmin() ) {
        my $msg = "You are not authorized to access this page.";
        $self->log( $msg . ". User: " . $self->authen->username );
        $self->add_message( 'error', $self->{lh}->maketext($msg) );
        $self->redirect( $self->{base_url} . '?rm=welcome' );
        return;
    }

    my %params = (
        'title'   => $self->{lh}->maketext('Add Domain'),
        'current' => 'domains',
    );

    return $self->tt_process( 'vdnsadm/domain/create.tpl', \%params );
}

sub show_add_domain {
    my $self = shift;

    # Get CGI Query object
    my $q = $self->query();

    my $domain = &VBoxAdm::Utils::trim( lc( $q->param('domain') ) );

    $self->{'Domain'}->create($domain);

    $self->redirect( $self->{base_url} . '?rm=domains' );
    return;
}

sub show_remove_domain {
    my $self = shift;

    # Get CGI Query object
    my $q = $self->query();

    my $domain_id = $q->param('domain_id');

    $self->{'Domain'}->delete($domain_id);

    $self->redirect( $self->{base_url} . '?rm=domains' );
    return;
}

sub show_update_domain {
    my $self = shift;

    # Get CGI Query object
    my $q = $self->query();

    my $domain_id = $q->param('domain_id');

    # TODO set params
    my %params = ( 'IsActive' => $q->param('is_active'), );

    $self->{'Domain'}->update( $domain_id, \%params );

    $self->redirect( $self->{base_url} . '?rm=domains' );
    return;
}

#
# Records
#

sub show_records {
    my $self = shift;

    # Get our database connection
    my $dbh = $self->dbh();

    # Get CGI Query object
    my $q = $self->query();

    my $page   = $q->param('page') || 1;
    my $search = $q->param('search');
    my %params = ( 'Search' => $search, );

    my @records = $self->{'Record'}->list( \%params );

    %params = (
        'title'   => $self->{lh}->maketext('VDnsAdm Records'),
        'current' => 'records',
        'records' => \@records,
        'domains' => [ $self->{'Domain'}->list() ],
        'search'  => $search,
    );

    return $self->tt_process( 'vdnsadm/record/list.tpl', \%params );
}

sub show_create_record {
    my $self = shift;

    if ( !$self->user->is_admin() ) {
        my $msg = "You are not authorized to access this page.";
        $self->log( $msg . ". User: " . $self->authen->username );
        $self->add_message( 'error', $self->{lh}->maketext($msg) );
        $self->redirect( $self->{base_url} . '?rm=welcome' );
        return;
    }

    # Get our database connection
    my $dbh = $self->dbh();

    # TODO use domain model
    my $query = "SELECT id,name,is_active FROM domains WHERE 1 ";
    my @args  = ();

    # Authorization
    if ( !$self->user->is_siteadmin() && $self->user->is_domainadmin() ) {
        $query .= "AND id = ? ";
        push( @args, $self->user->get_domain_id() );
    }
    $query .= "ORDER BY name";
    my $sth = $dbh->prepare($query)
      or $self->{'logger'}->log( message => 'Could not prepare Query: ' . $query . ', Error: ' . DBI->errstr );
    $sth->execute(@args)
      or $self->{'logger'}->log( message => 'Could not execute Query: ' . $query . ', Args: ' . join( "-", @args ) . ', Error: ' . $sth->errstr );

    my @domains = ();
    while ( my @row = $sth->fetchrow_array() ) {
        push( @domains, { id => $row[0], name => $row[1], is_active => $row[2], } );
    }

    my %params = (
        'title'   => $self->{lh}->maketext('Add Mailbox'),
        'domains' => \@domains,
        'current' => 'mailboxes',
    );

    return $self->tt_process( 'vdnsadm/record/create.tpl', \%params );
}

sub show_add_record {
    my $self = shift;

    # Get CGI Query object
    my $q = $self->query();

    my $domain_id = $q->param('domain');
    my $name      = $q->param('name');
    my $type      = $q->param('type');
    my $content   = $q->param('content');
    my $ttl       = $q->param('ttl');
    my %params    = (
        'Prio'       => $q->param('prio'),
        'ChangeDate' => $q->param('changedate'),
        'Ordername'  => $q->param('ordername'),
        'Auth'       => $q->param('auth'),
    );

    $self->{'Record'}->create( $domain_id, $name, $type, $content, $ttl, \%params );

    $self->redirect( $self->{base_url} . '?rm=records' );
    return;
}

sub show_remove_record {
    my $self = shift;

    # Get CGI Query object
    my $q = $self->query();

    my $record_id = $q->param('record_id');

    $self->{'Record'}->delete($record_id);

    $self->redirect( $self->{base_url} . '?rm=records' );
    return;
}

sub show_edit_record {
    my $self = shift;

    if ( !$self->user->is_admin() ) {
        my $msg = "You are not authorized to access this page.";
        $self->log( $msg . ". User: " . $self->authen->username );
        $self->add_message( $self->{lh}->maketext($msg) );
        $self->redirect( $self->{base_url} . '?rm=welcome' );
        return;
    }

    # Get our database connection
    my $dbh = $self->dbh();

    # Get CGI Query object
    my $q = $self->query();

    my $record_id  = $q->param('record_id');
    my $record_ref = $self->{'Mailbox'}->read($record_id);
    my $domain_id  = $record_ref->{'domain_id'};

    my %params = (
        'title'     => $self->{lh}->maketext('Edit Record'),
        'record_id' => $record_id,
        'current'   => 'records',
    );
    foreach my $key ( keys %{$record_ref} ) {
        $params{$key} = $record_ref->{$key};
    }

    return $self->tt_process( 'vdnsadm/record/edit.tpl', \%params );
}

sub show_update_record {
    my $self = shift;

    # Get CGI Query object
    my $q = $self->query();

    my $record_id = $q->param('record_id');
    my $params    = {};

    # TODO name keys in tempaltes acordingly and remove key translatation ... everywhere
    my %keys = (
        'name'        => 'Name',
        'type'        => 'Type',
        'content'     => 'Content',
        'ttl'         => 'TTL',
        'prio'        => 'Prio',
        'change_date' => 'ChangeDate',
        'ordername'   => 'Ordername',
        'auth'        => 'Auth',
    );
    foreach my $key ( keys %keys ) {
        my $tkey = $keys{$key};
        if ( defined( $q->param($key) ) ) {
            $params->{$tkey} = $q->param($key);
        }
    }

    $self->{'Record'}->update( $record_id, $params );
    $self->redirect( $self->{base_url} . '?rm=records' );
    return;
}

#
# Log
#

sub show_log {
    my $self = shift;

    if ( !$self->user->is_siteadmin() ) {
        my $msg = "You are not authorized to access this page.";
        $self->log( $msg . ". User: " . $self->authen->username );
        $self->add_message( 'error', $self->{lh}->maketext($msg) );
        $self->redirect( $self->{base_url} . '?rm=welcome' );
        return;
    }

    # Get CGI Query object
    my $q = $self->query();

    # Get our database connection
    my $dbh = $self->dbh();

    my $search = $q->param('search') || undef;
    my $page   = $q->param('page')   || 1;

    my @args  = ();
    my $query = "FROM log ";
    if ($search) {
        $query .= "WHERE msg LIKE ? ";
        $search =~ s/%//g;
        my $search_arg = "%" . $search . "%";
        push( @args, $search_arg );
    }
    $query .= "ORDER BY ts DESC";

    # Get the actual data
    my $sth = $dbh->prepare( 'SELECT ts,msg ' . $query )
      or $self->{'logger'}->log( message => 'Could not prepare Query: ' . $query . ', Error: ' . DBI->errstr );
    $sth->execute(@args)
      or $self->{'logger'}->log( message => 'Could not execute Query: ' . $query . ', Args: ' . join( "-", @args ) . ', Error: ' . $sth->errstr );

    my @log = ();
    while ( my @row = $sth->fetchrow_array() ) {
        push( @log, { ts => $row[0], msg => $row[1], } );
    }
    $sth->finish();

    my %params = (
        'title'   => $self->{lh}->maketext('VBoxAdm Log'),
        'current' => 'log',
        'log'     => \@log,
        'search'  => $search,
    );

    return $self->tt_process( 'vwebadm/log.tpl', \%params );
}

#
# Admins
#

sub show_admins {
    my $self = shift;

    if ( !$self->user->is_siteadmin() ) {
        my $msg = "You are not authorized to access this page.";
        $self->log( $msg . ". User: " . $self->authen->username );
        $self->add_message( 'error', $self->{lh}->maketext($msg) );
        $self->redirect( $self->{base_url} . '?rm=welcome' );
        return;
    }

    # Get our database connection
    my $dbh = $self->dbh();

    # Get CGI Query object
    my $q = $self->query();

    my $page   = $q->param('page') || 1;
    my $search = $q->param('search');
    my %params = (
        'Search'  => $search,
        'IsAdmin' => 1,
    );

    my @mailboxes = $self->{'User'}->list( \%params );

    %params = (
        'title'   => $self->{lh}->maketext('VDnsAdm Admins'),
        'current' => 'admins',
        'admins'  => \@mailboxes,
        'search'  => $search,
    );

    return $self->tt_process( 'vdnsadm/user/admins.tpl', \%params );
}

1;

__END__

=head1 NAME

VDnsAdm::Controller::Frontend - Frontend for VDnsAdm

=head1 VERSION

This documentation refers to VDnsAdm::Controller::Frontend version @VERSION@
built on @BUILDDATE@.

=head1 SYNOPSIS

    use VDnsAdm::Controller::Frontend;
		my $vadm = VDnsAdm::Controller::Frontend->new();
		$vadm->run();

=head1 DESCRIPTION

This module implements the controller for the webinterface of VDnsAdm.

=head1 SUBROUTINES/METHODS

TODO

=head1 DIAGNOSTICS

TODO

=head1 CONFIGURATION AND ENVIRONMENT

TODO

=head1 DEPENDENCIES

TODO

=head1 INCOMPATIBILITIES

None known.

=head1 BUGS AND LIMITATIONS

There are no known bugs in this module.
Please report problems to Dominik Schulz (dominik.schulz@gauner.org)
Patches are welcome.

=head1 AUTHOR

Dominik Schulz (dominik.schulz@gauner.org)

=head1 LICENCE AND COPYRIGHT

Copyright (c) 2010 Dominik Schulz (dominik.schulz@gauner.org). All rights reserved.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut
